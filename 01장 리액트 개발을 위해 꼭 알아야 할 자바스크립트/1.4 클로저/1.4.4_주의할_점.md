# 1.4.4 주의할 점

## 스코프 주의

```js
for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i)
    }, i * 1000)
}
```

위 코드를 실행하면 0, 1, 2, 3, 4초 뒤에 5만 출력됨. `i`가 전역 변수로 작동하기 때문. 자바스크립트는 기본적으로 함수 레벨 스코프를 따르고 있기 때문에 `var`는 `for` 문의 존재와 상관없이 해당 구문이 선언된 함수 레벨 스코프를 바라보고 있으므로 함수 내부 실행이 아니라면 전역 스코프에 `var i`가 등록돼 있을 것. `for` 문을 다 순회한 이후, 태스크 큐에 있는 `setTimeout`을 실행하려고 했을 때, 이미 전역 레벨에 있는 `i`는 5로 업데이트가 완료돼 있음.

그럼 0, 1, 2, 3, 4초 뒤에 각 0, 1, 2, 3, 4를 출력하고 싶다면?

### let 사용

```js
for (let i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i)
    }, i * 1000)
}
```

`let`은 기본적으로 블록 레벨 스코프를 가지게 되므로 `let i`가 `for`문을 순회하면서 각각의 스코프를 갖게 됨. 이는 `setTimeout`이 실행되는 시점에도 유효해서 각 콜백이 의도한 `i` 값을 바라보게 할 수 있음

### 클로저 제대로 활용

```js
for (var i = 0; i < 5; i++) {
  setTimeout(
    (function(sec) {
      return function() {
        console.log(sec)
      }
    })(i),
    i * 1000,
  )
}
```

위 함수는 `for` 문 내부에 즉시 실행 익명 함수를 선언함. 이 즉시 실행 함수는 `i`를 인수로 받는데, 이 함수 내부에서는 이를 `sec`이라고 하는 인수에 저장해 두었다가 `setTimeout` 콜백 함수에 넘기게 됨. 이렇게 되면 `setTimeout`의 콜백 함수가 바라보는 클로저는 즉시 실행 익명 함수가 되는데, 이 즉시 실행 익명 함수는 각 `for` 문마다 생성되고 실행되기를 반복함. 그리고 각각의 함수는 고유한 스코프, 즉 고유한 `sec`을 가지게 되므로 올바르게 실행할 수 있음.

## 클로저의 비용

클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생함. 아래 두 함수는 엄청나게 긴 작업(길이가 천만인 배열)을 동일하게 처리함. 클로저 유무에 따라 자바스크립트 코드에 어떤 차이가 있는지 알아보자.

```js
// 일반적인 함수
const aButton = document.getElementById('a')

function heavyJob() {
  const longArr = Array.from({ length: 10000000 }, (_, i) => i + 1)
  console.log(longArr.length)
}

aButton.addEventListener('click', heavyJob)

// 클로저라면??
function heavyJobWithClosure() {

```
