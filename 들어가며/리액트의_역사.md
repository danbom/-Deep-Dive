## 리액트의 역사

### 페이스북의 도전
- 기존 웹 생태계
	- LAMP 스택 : L(Linux), A(Apache) 웹 서버, MySQL, PHP
	- 데이터베이스에서 필요한 데이터를 불러온 다음, 웹 서버에서 HTML 페이지를 만들어 클라이언트에 제공하는 방식
	- 콘텐츠는 서버에서 동적으로 생성하고, 웹 브라우저는 단순히 이를 다운로드 받아 렌더링하며, 자바스크립트는 폼 처리와 같은 부수적인 역할만 하는 방식

-  제이쿼리의 인기
	- 자바스크립트를 좀 더 편리하기 사용할 수 있음
	- 점차 자바스크립트의 비공식 표준으로 자리잡음
- 자바스크립트 표준화, ES5(ECMAScript 5)
	- WebSocket, Canvas, SVG, Geolocation 등 다양한 기능을 브라우저에서 지원하기 시작
	- 자바스크립트는 적극적으로 DOM(Document Object Model)을 수정해 사용자에게 다양한 인터렉션을 보여주었고, Ajax(Asynchronous JavaScript and XML)를 활용해 서버뿐만 아니라 클라이언트에서도 서버와 통신해서 데이터를 불러오기 시작
	- 이에 따라 자바스크립트 코드가 점차 복잡해지기 시작
- 새로운 프레임워크 AngularJS, Backbone.js 등장
	- 각각 MVVM(Model-View-ViewModel)과 MVC(Model-View-Controller) 패턴을 기반으로 자바스크립트 코드를 체계화하고자 노력함
- 전 세계 인기 소셜 네트워크 서비스가 된 페이스북이 직면한 문제
	- 페이스북은 성능을 위해 최대한 서버에서 렌더링하는 기술 사용했고, 자바스크립트 번들의 크기를 줄이는 데 오랜 기간 심혈을 기울였지만 서버 렌더링이 처리할 수 있는 규모에는 한계가 있을 수 밖에 없었음
	- 예시로 페이스북의 여러 페이지는 실시간성을 강조하는 기능이 곳곳에 있었기 때문에 자바스크립트에 의존할 수 밖에 없었음
- 스파르탄 프로젝트의 실패
	- 배경
		- 당시 애플의강력한 앱 규제에 반발해 만들어진 프로젝트
		- 페이스북 iOS 앱 대신 애플의 사파리(Webkit)에서 작동할 수 있는 페이스북을 만들기 위해 추진
		- 이 무렵 등장한 HTML5가 표준만 잘 지킨다면 PC나 모바일 환경에 상관없이 모두 동일한 서비스를 제공할 수 있는 가능성 제시
	- 설명
		- HTML5 기반으로 페이스북을 완전히 재작성하는 스파르탄 프로젝트 시작
	- 실패
		- 네이티브로 만든 애플리케이션이 HTML5로 만든 것보다 훨씬 빠르고 안정적이었기 때문
		- 하지만 앱과 모바일, PC에서 동일한 사용자 경험을 주고자 하는 도전은 여러 서비스에 긍정적인 영향을 미침
		- 이처럼 HTML5 기반 하이브리드 앱으로 개발하는 방식은 인터랙션이 복잡하지 않거나 성능이 크게 중요하지 않은 서비스에서 여전히 선호

### BoltJS의 등장과 한계
- BoltJS 등장 이유
	- 기존 바닐라JS, 제이쿼리, Angular, Backbone.js로는 페이스북의 복잡한 요구사항을 처리하면서도 사용자에게 만족스러운 경험을 안겨주기 어렵다
- BoltJS 주요 설명
	- createClass로 내부에 객체를 선언해서 컴포넌트를 만드는 방식(리액트 초기 버전의 React.createClass), 한 가지 특이한 점은 BoltJS 외에도 Javelin이나 View 같은 다른 라이브러리도 함께 쓰임 = 여러 라이브러리를 함께 써서 구축된 프레임워크임
- BoltJS 실패 
	- 페이스북 개발자가 BoltJS로 페이스북 클론 코딩하기 위해 다양한 기능 구현했지만 프로젝트의 아키텍처는 점점 복잡해졌고 점차 변화를 가져가기 어려웠다고 밝힘
- Fbolt 등장
	- Functional Bolt, 리액트의 시초. 함수형을 지향하는 새로운 버전의 BoltJS.
	- 배경
		- 이 당시 제안됐던 아이디어 중 하나가 애플리케이션에서 API의 변화에 따라 무언가 변경되면 단순히 UI를 초기화하고 새로 렌더링하자는 것이었는데, 이 당시 이러한 접근법은 프런트엔드 개발자 사이에서 매우 파격적인 접근법이었음
		- 당시 대부분의 프레임워크는 양방향 바인딩 구조를 채택해 모델과 뷰가 밀접한 관계를 맺고 서로가 서로를 변경할 수 있는 구조였음. 이 방식은 코드를 작성하는 것은 간단하지만 변경된 DOM 추적이 어렵고 왜 이렇게 변경됐는지 역시 추적하기 어려워 수많은 버그가 발생함
	- 방식
		- 모델이 뷰를 변경하는 단방향 방식으로, 모델의 데이터가 변경되어 뷰가 변경되어야 하면 이전 DOM을 버리고 새롭게 렌더링하는 방식 제안, 그러나 DOM의 변경을 최소한으로 하는 것이 성능을 위한 최선의 방법으로 여겨졌던 시기라 의구심 품는 사람이 많았음

### 페이스북 팀의 대안으로 떠오른 리액트
- UFI(Universal Feedback Interface) 구현
	- 리액트의 첫 번째 프로젝트
	- 게시물 하단에 있는 댓글, 공유 버튼이 있는 화면
	- 좋아요를 누르거나 댓글을 다는 행위 등이 모두 즉각적으로 이루어져야함
	- 여기에서 JSX 구문과 Flux 패턴에 대한 아이디어 등장
- 리액트로 인스타그램 개발 시작 및 페이스북의 거대한 PHP 애플리케이션 중 일부를 리액트로 대체하기 시작
- 리액트를 오픈소스로 공개하고자 하는 노력
- JSConf US에서 리액트와 JSX(embedded XML) 공개


### 리액트에 대한 회의적인 의견과 비판
- 개발자들이 리액트를 싫어한 이유
	- JSX 구문의 특징, 자바스크립트 코드 내에 HTML을 추가한다는 것에 호의적이지 않았음
	- HTML과 JS 파일을 분리하는 것이 관심사 분리의 원칙을 지키기 위한 기초적인 사실로 받아들여졌기 때문
- 관점의 차이
	- 당시의 관심사 분리는 파일의 역할을 기반으로 관심사가 분리되는 것에 초점이 맞춰져 있었음
	- 리액트의 관심사 분리는 컴포넌트 기반
	- 즉, 관심사 분리의 원칙이라는 개념하에 리액트와 기존 프런트엔드 프로젝트가 서로 다른 방식 채택한 차이만 있을 

### 드디어 빛을 보는 리액트
- 페이스북 밖의 오픈소스 컨트리뷰터에게서 많은 아이디어와 도움 얻

결론
- Node.js 공부해라
